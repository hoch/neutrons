<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TEST</title>
    <script src="lib/fft.js"></script>
    <link rel="stylesheet" href="styles.css">
    <script src="slides.js" type="module"></script>
    <script type="module">
        import {readAudio, maxima} from "./modules/standard.js";
        import {Policy} from "./modules/policy.js";
        import {dbToGain, gainToDb, normalise, Windows} from "./modules/neutrons.js";
        import {Harmonic} from "./worklets/PadSynth.js";

        const context = Policy.newAudioContext();

        readAudio(context, "files/aaaa.wav").then(buffer => {
            const frames = buffer.getChannelData(0);
            const padSize = 1 << 18;
            const windowSize = 1 << 13;
            const ratio = padSize / (windowSize / 2) | 0;
            console.log("ratio", ratio);
            const window = Windows.generate(Windows.Blackman, windowSize);
            const fft = new FFT(windowSize);
            const imag = new Float32Array(windowSize);
            let sum = new Float32Array(windowSize / 2);

            for (let i = 0; i < frames.length - windowSize; i += windowSize) {
                const real = frames.slice(i, i + windowSize);
                for (let j = 0; j < windowSize; j++) {
                    real[j] *= window[j];
                }
                imag.fill(0.0);
                fft.process(real, imag);
                for (let j = 0; j < windowSize / 2; j++) {
                    // options: max or sum
                    sum[j] = Math.max(sum[j], Math.sqrt(real[j] * real[j] + imag[j] * imag[j]));
                }
            }
            normalise(sum);
            const dbSum = sum.map(gainToDb);
            const canvas = document.querySelector("canvas");
            const graphics = canvas.getContext("2d");
            graphics.fillStyle = "white";
            const dbMin = -72.0;
            const dbMax = 0.0;
            for (let i = 0; i < windowSize / 2; i++) {
                const db = dbSum[i];
                if (db > dbMin) {
                    const yNorm = (db - dbMin) / (dbMax - dbMin);
                    const yHeight = canvas.height - yNorm * canvas.height;
                    graphics.fillRect(i, yHeight, 1, canvas.height - yHeight);
                }
            }
            // find max peak index for root overtone and start from there
            console.log("numBins", sum.length);
            const harmonics = [];
            for (let i = 1; i < sum.length; i++) {
                const position = i / ratio;
                harmonics.push(new Harmonic(position, sum[i], 0.01));
            }
            console.log(harmonics);

            const context = new AudioContext();
            const worker = new Worker("./workers/pad.js");
            worker.postMessage({
                action: "init",
                value: {fftSize: padSize, sampleRate: context.sampleRate, frequencies: [380]}
            });
            worker.onmessage = event => {
                const tables = event.data;
                const table = tables[0];
                const tableBuffer = context.createBuffer(1, table.length, context.sampleRate);
                tableBuffer.copyToChannel(table, 0, 0);
                const bufferSource = context.createBufferSource();
                bufferSource.buffer = tableBuffer;
                bufferSource.loop = true;
                bufferSource.start(0.0, 0.0, 5.0);
                bufferSource.connect(context.destination);
            };
            worker.postMessage({
                action: "update",
                value: harmonics
            });
        });
    </script>
</head>
<body>
<canvas width="1024" height="512"></canvas>
</body>
</html>