<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Time Stretching</title>
    <link rel="stylesheet" href="styles.css">
    <script src="slides.js" type="module"></script>
    <script src="./lib/fft.js"></script>
    <script type="module">
        import {Policy} from "./modules/policy.js";
        import {maxima, readAudio, replaceElement} from "./modules/standard.js";
        import {PlotterCanvas, PlotterRangeEvents} from "./modules/plotter.js";
        import {normalise, Windows} from "./modules/neutrons.js";
        import {extrema} from "./third/diff.js";
        import {Fragmentation, Sequencer} from "./modules/sequencing.js";

        const context = Policy.newAudioContext();

        // readAudio(context, "files/loops/103616__deller24__loop3.wav")
        readAudio(context, "files/loops/crazy-drumbeat-1.wav")
            .then(buffer => {
                const startTime = context.currentTime;

                const overlap = 16;
                let realPeaks;
                realPeaks = [7, 656, 966, 1294, 1964, 2275, 2587, 3543, 3865, 4509, 4847, 5137, 5798, 6143, 6436, 7064, 7729, 8689, 9007, 9632, 9990, 10280, 10941, 11251, 11579, 12249, 12561, 12873, 13810, 14150, 14795, 15133, 15423, 15744, 16065, 16724, 17350, 18015, 19274];
                realPeaks = realPeaks.map(x => x * overlap / buffer.sampleRate);

                const scale = 1.0;
                const fadeOutTime = 0.001;
                const loopDuration = buffer.duration;
                const numPeaks = realPeaks.length;

                /*for (let j = 0; j < 16; j++) {
                    const loopTime = startTime + j * loopDuration * scale;
                    for (let i = 0; i < numPeaks; i++) {
                        const peakTime = realPeaks[i];
                        const nextTime = i + 1 === numPeaks ? loopDuration : realPeaks[i + 1];
                        const grainDuration = (nextTime - peakTime) * Math.min(1.0, scale);
                        const localTime = loopTime + peakTime * scale;
                        const bufferSource = context.createBufferSource();
                        bufferSource.buffer = buffer;
                        bufferSource.loop = false;
                        const gainNode = context.createGain();
                        gainNode.gain.value = 1.0;
                        gainNode.gain.setValueAtTime(1.0, localTime);
                        gainNode.gain.setValueAtTime(1.0, localTime + grainDuration - fadeOutTime);
                        gainNode.gain.linearRampToValueAtTime(0.0, localTime + grainDuration);
                        bufferSource.start(localTime, peakTime, localTime + grainDuration);
                        bufferSource.connect(gainNode);
                        gainNode.connect(context.destination);
                    }
                }*/

                let sliceIndex = 0;
                let loopIndex = 0;
                const sequencer = new Sequencer(() => context.currentTime * 1000.0);
                sequencer.bpm.value = 240.0;
                sequencer.addProcessor((sequencer, t0, t1) => {
                    let peakLocal = realPeaks[sliceIndex];
                    let peakTime = (peakLocal + loopIndex * loopDuration) * scale;
                    while (t0 <= peakTime && peakTime < t1) {
                        const nextPeakLocal = sliceIndex + 1 === numPeaks ? loopDuration : realPeaks[sliceIndex + 1];
                        const peakDuration = (nextPeakLocal - peakLocal) * scale;
                        const bufferSource = context.createBufferSource();
                        bufferSource.buffer = buffer;
                        bufferSource.loop = false;
                        const gainNode = context.createGain();
                        gainNode.gain.value = 1.0;
                        gainNode.gain.setValueAtTime(1.0, peakTime);
                        gainNode.gain.setValueAtTime(1.0, peakTime + peakDuration - fadeOutTime);
                        gainNode.gain.linearRampToValueAtTime(0.0, peakTime + peakDuration);
                        bufferSource.start(peakTime, peakLocal, peakDuration);
                        bufferSource.connect(gainNode);
                        gainNode.connect(context.destination);

                        if (++sliceIndex === numPeaks) {
                            sliceIndex = 0;
                            loopIndex++;
                        }
                        peakLocal = realPeaks[sliceIndex];
                        peakTime = (peakLocal + loopIndex * loopDuration) * scale;
                    }
                });
                sequencer.start();
            });
    </script>
</head>
<body>
<header>
    <h1>Klangwerk</h1>
    <h2>Time Stretching | Playback</h2>
</header>
<div style="width: 100%; height: 400px;" id="container">
    <div id="waveform"></div>
    <div id="spectrum"></div>
</div>
</body>
</html>