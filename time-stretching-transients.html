<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Time Stretching</title>
    <link rel="stylesheet" href="styles.css">
    <script src="slides.js" type="module"></script>
    <script src="./lib/fft.js"></script>
    <script src="./third/brain.js"></script>
    <script type="module">
        import {Policy} from "./modules/policy.js";
        import {readAudio, replaceElement} from "./modules/standard.js";
        import {PlotterCanvas, PlotterRangeEvents} from "./modules/plotter.js";
        import {normalise, Windows} from "./modules/neutrons.js";
        import {extrema} from "./third/diff.js";

        const context = Policy.newAudioContext();

        const createNeuralNetwork = () => {
            return new brain.NeuralNetwork({
                binaryThresh: 0.5,     // ¯\_(ツ)_/¯
                hiddenLayers: [5, 4, 3],     // array of ints for the sizes of the hidden layers in the network
                activation: 'sigmoid'  // supported activation types: ['sigmoid', 'relu', 'leaky-relu', 'tanh']
            });
        };

        function startEditManually(spectrum) {
            const element = spectrum.canvas;
            let from = -1;
            const mouseMove = event => {
                const clientRect = element.getBoundingClientRect();
                const to = spectrum.range.xToIndex(event.clientX - clientRect.x);
                spectrum.removeMarkers(Math.min(from, to), Math.max(from, to));
                from = to;
            };
            const mouseUp = ignore => {
                element.removeEventListener("mousemove", mouseMove);
                element.removeEventListener("mouseup", mouseUp);
            };
            const mouseDown = event => {
                if (event.shiftKey && event.buttons) {
                    const clientRect = element.getBoundingClientRect();
                    from = spectrum.range.xToIndex(event.clientX - clientRect.x);
                    element.addEventListener("mousemove", mouseMove);
                    element.addEventListener("mouseup", mouseUp);
                }
            };
            element.addEventListener("mousedown", mouseDown);

            window.addEventListener("keydown", event => {
                if (!event.repeat && event.keyCode === 32) {
                    console.log(spectrum.markers);
                }
            });
        }

        // readAudio(context, "files/loops/103616__deller24__loop3.wav")
        readAudio(context, "files/loops/crazy-drumbeat-1.wav")
            .then(buffer => {
                const startTime = context.currentTime;

                const bufferSource = context.createBufferSource();
                bufferSource.buffer = buffer;
                bufferSource.loop = true;
                // bufferSource.start(startTime);
                bufferSource.connect(context.destination);

                let now;
                const channelData = buffer.getChannelData(0);
                const length = channelData.length;
                const fftSize = 1024;
                const fftBins = fftSize / 2;
                const fft = new FFT(fftSize);
                const real = new Float32Array(fftSize);
                const imag = new Float32Array(fftSize);
                const win = Windows.generate(Windows.BlackmanHarris, fftSize);
                const fftOverlap = 16;
                const n = Math.floor(length / fftOverlap);
                now = performance.now();
                const transients = new Float64Array(n);
                for (let i = 0; i <= n; i++) {
                    const s0 = i * fftOverlap;
                    const s1 = s0 + fftSize;
                    const sn = Math.min(length, s1);
                    let j = s0, k = 0;
                    for (; j < sn; j++, ++k) {
                        real[k] = channelData[j] * win[k];
                    }
                    for (; k < fftSize; k++) {
                        real[k] = 0.0;
                    }
                    imag.fill(0.0);
                    fft.process(real, imag);
                    for (let l = 0; l < fftBins; l++) {
                        transients[i] += Math.sqrt(real[l] * real[l] + imag[l] * imag[l]);
                    }
                }
                console.log("length", length);
                console.log("fftSize", fftSize);
                console.log("fftOverlap", fftOverlap);
                console.log("performed", n, "fft in", (performance.now() - now).toFixed(1), "ms");

                normalise(transients);

                const waveform = new PlotterCanvas();
                waveform.setWaveform(channelData);
                const spectrum = new PlotterCanvas();
                spectrum.setWaveform(transients);
                spectrum.setYRange(1.0, 0.0);

                const maxPeaks = extrema(transients, 0.05).maxlist.map(x => parseInt(x, 10));
                for (let i = 0; i < maxPeaks.length; i++) {
                    spectrum.addMarker(maxPeaks[i]);
                }

                startEditManually(spectrum);

                const collect = (array, index, half) => {
                    const n = half * 2 + 1;
                    const neighbours = new Float32Array(n);
                    for (let j = 0; j < n; j++) {
                        const nI = j - half + index;
                        neighbours[j] = 0 > nI ? 0.0 : nI >= array.length ? 0.0 : array[nI];
                    }
                    return neighbours;
                };

                const train = true;
                if (train) {
                    // traning data for 'files/loops/crazy-drumbeat-1.wav'
                    const realPeaks = [586, 872, 1174, 1785, 2074, 2361, 2603, 2944, 3231, 3536, 4127, 4435, 4707, 5311, 5626, 5898, 6474, 7085, 7668, 7965, 8260, 8849, 9163, 9433, 10036, 10322, 10622, 11228, 11525, 11811, 12394, 12681, 12985, 13576, 13885, 14158, 14447, 14743, 15073, 15349, 15924, 16535, 17118, 17692, 7, 10941, 19274];
                    for (let i = 0; i < realPeaks.length; i++) {
                        spectrum.addMarker(realPeaks[i]);
                    }

                    const trainingData = [];
                    for (let i = 0; i < maxPeaks.length; i++) {
                        const peakIndex = maxPeaks[i];
                        const neighbours = collect(transients, peakIndex, 16);
                        const quality = realPeaks.includes(peakIndex) ? 1.0 : 0.0;
                        trainingData.push({input: neighbours, output: [quality]});
                    }

                    const net = createNeuralNetwork();
                    now = performance.now();
                    console.log(net);
                    console.log("learning", trainingData.length, "sets");
                    net.trainAsync(trainingData, {
                        // Defaults values --> expected validation
                        iterations: 2000000,    // the maximum times to iterate the training data --> number greater than 0
                        errorThresh: 0.005,   // the acceptable error percentage from training data --> number between 0 and 1
                        log: true,           // true to use console.log, when a function is supplied it is used --> Either true or a function
                        logPeriod: 500,        // iterations between logging out --> number greater than 0
                        learningRate: 0.3,    // scales with delta to effect training rate --> number between 0 and 1
                        momentum: 0.1,        // scales with next layer's change value --> number between 0 and 1
                        callback: null,       // a periodic call back that can be triggered while training --> null or function
                        callbackPeriod: 1000,   // the number of iterations through the training data between callback calls --> number greater than 0
                        timeout: Infinity     // the max number of milliseconds to train for --> number greater than 0
                    }).then(x => {
                        console.log(x);
                        console.log("training complete", performance.now() - now, "ms");
                        console.log(JSON.stringify(net.toJSON()));
                        console.log(">>>", net.run(collect(transients, 2074, 16)));
                        console.log(">>>", net.run(collect(transients, maxPeaks[100], 16)));
                    });
                }

                const container = document.querySelector("div#container");
                PlotterRangeEvents.attach(container, waveform.range);
                PlotterRangeEvents.attach(container, spectrum.range);
                replaceElement(waveform.domElement, document.querySelector("div#waveform"));
                replaceElement(spectrum.domElement, document.querySelector("div#spectrum"));

                const update = () => {
                    const seconds = context.currentTime - startTime;
                    waveform.setCursor((seconds * buffer.sampleRate) % length);
                    window.requestAnimationFrame(update);
                };
                update();
            });
    </script>
</head>
<body>
<header>
    <h1>Klangwerk</h1>
    <h2>Time Stretching | Transients</h2>
</header>
<div style="width: 100%; height: 400px;" id="container">
    <div id="waveform"></div>
    <div id="spectrum"></div>
</div>
</body>
</html>